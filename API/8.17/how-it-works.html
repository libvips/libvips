<!--
SPDX-FileCopyrightText: libvips team and contributors

SPDX-License-Identifier: LGPL-2.1-or-later
-->

<!DOCTYPE html>
<html lang="en">
<head>
  <title>Vips &ndash; 8.0: Technical background &gt; Evaluation</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta charset="utf-8" />

  
  <meta property="og:type" content="website"/>

  

  
  <meta property="og:title" content="Vips: Technical background &gt; Evaluation"/>
  <meta property="og:description" content="Reference for Vips-8.0: Technical background &gt; Evaluation"/>
  <meta name="twitter:title" content="Vips: Technical background &gt; Evaluation"/>
  <meta name="twitter:description" content="Reference for Vips-8.0: Technical background &gt; Evaluation"/>


  
  <meta name="twitter:card" content="summary"/>

  
  
  
  <link rel="search" type="application/opensearchdescription+xml" title="Vips" href="opensearch.xml">
  
  

  <link rel="stylesheet" href="style.css" type="text/css" />

  

  
  <script src="urlmap.js"></script>
  
  
  <script src="fzy.js"></script>
  <script src="search.js"></script>
  
  <script src="main.js"></script>

  
</head>

<body>
  <div id="body-wrapper" tabindex="-1">

    <nav class="sidebar devhelp-hidden">
      
      
      <div class="search section">
        <form id="search-form" autocomplete="off">
          <input id="search-input" type="text" name="do-not-autocomplete" placeholder="Click, or press 's' to search" autocomplete="off"/>
        </form>
      </div>
      
      <div class="section namespace">
        <h3><a href="index.html">Vips</a></h3>
        <p>API Version: 8.0</p>
        
        <p>Library Version: 8.17</p>
        
      </div>
      
      
      <div class="section generator">
        <p>Generated by <a href="https://gitlab.gnome.org/GNOME/gi-docgen">gi-docgen</a> 2025.3</p>
      </div>
    </nav>

    <button id="btn-to-top" class="hidden"><span class="up-arrow"></span></button>

    
<section id="main" class="content">
  
  <h4 id="title" style="display:flex;">
    Technical background &gt; Evaluation
    <a href="#title" class="anchor"></a>
    
    <a class="srclink" title="go to source location" href="https://github.com/libvips/libvips/blob/master/doc/how-it-works.md">[src]</a>
    
  </h4>
  
  <section>
    <div class="docblock">
    <p>Compared to most image processing libraries, libvips needs little <span class="caps">RAM</span> and runs
quickly, especially on machines with more than one <span class="caps">CPU</span>. libvips achieves this
improvement by only keeping the pixels currently being processed in <span class="caps">RAM</span>
and by having an efficient, threaded image <span class="caps">IO</span> system. This page explains
how these features are&nbsp;implemented.</p>
<h2 id="images">Images<a class="md-anchor" href="#images" title="Permanent link"></a></h2>
<p>libvips images have three dimensions: width, height and bands. Bands usually
(though not always) represent colour. These three dimensions can be any
size up to 2 ** 31 elements. Every band element in an image has to have the
same format. A format is an 8-, 16- or 32-bit int, signed or unsigned, 32-
or 64-bit float, and 64- or 128-bit&nbsp;complex.</p>
<h2 id="regions">Regions<a class="md-anchor" href="#regions" title="Permanent link"></a></h2>
<p>An image can be very large, much larger than the available memory, so you
can&#8217;t just access pixels with a pointer&nbsp;*.</p>
<p>Instead, you read pixels from an image with a region. This is a rectangular
sub-area of an image. In C, the <span class="caps">API</span> looks&nbsp;like:</p>
<div class="codehilite"><pre><span></span><code><span class="n">VipsImage</span><span class="w"> </span><span class="o">*</span><span class="n">image</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vips_image_new_from_file</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="n">VipsRegion</span><span class="w"> </span><span class="o">*</span><span class="n">region</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vips_region_new</span><span class="p">(</span><span class="n">image</span><span class="p">);</span>

<span class="c1">// ask for a 100x100 pixel region at 0x0 (top left)</span>
<span class="n">VipsRect</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">top</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="p">};</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">vips_region_prepare</span><span class="p">(</span><span class="n">region</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">r</span><span class="p">))</span>
<span class="w">    </span><span class="n">vips_error</span><span class="p">(...);</span>

<span class="c1">// get a pointer to the pixel at x, y, where x, y must</span>
<span class="c1">// be within the region</span>

<span class="c1">// as long as you stay within the valid area for the region,</span>
<span class="c1">// you can address pixels with regular pointer arithmetic</span>

<span class="c1">// compile with -DDEBUG and the macro will check bounds for you</span>

<span class="c1">// add VIPS_REGION_LSKIP() to move down a line</span>
<span class="n">VipsPel</span><span class="w"> </span><span class="o">*</span><span class="n">pixel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VIPS_REGION_ADDR</span><span class="p">(</span><span class="n">region</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>

<span class="c1">// you can call &lt;a href=&quot;method.Region.prepare.html&quot;&gt;&lt;code&gt;vips_region_prepare()&lt;/code&gt;&lt;/a&gt; many times</span>

<span class="c1">// everything in libvips is a GObject ... when you&#39;re done,</span>
<span class="c1">// just free with</span>
<span class="n">g_object_unref</span><span class="p">(</span><span class="n">region</span><span class="p">);</span>
</code></pre></div>

<p>The action that <a href="method.Region.prepare.html"><code>vips_region_prepare()</code></a> takes varies with the type of
image. If the image is a file on disc, for example, then libvips will arrange
for a section of the file to be read&nbsp;in.</p>
<p>(* there is an image access mode where you can just use a pointer, but
it&#8217;s rarely&nbsp;used)</p>
<h2 id="partial-images">Partial images<a class="md-anchor" href="#partial-images" title="Permanent link"></a></h2>
<p>A partial image is one where, instead of storing a value for each pixel,
libvips stores a function which can make any rectangular area of pixels
on&nbsp;demand.</p>
<p>If you use <a href="method.Region.prepare.html"><code>vips_region_prepare()</code></a> on a region created on a partial image,
libvips will allocate enough memory to hold the pixels you asked for and use
the stored function to calculate values for just those pixels&nbsp;*.</p>
<p>The stored function comes in three parts: a start function, a generate
function and a stop function. The start function creates a state, the
generate function uses the state plus a requested area to calculate pixel
values and the stop function frees the state again. Breaking the stored
function into three parts is good for <span class="caps">SMP</span> scaling: resource allocation and
synchronisation mostly happens in start functions, so generate functions
can run without having to talk to each&nbsp;other.</p>
<p>libvips makes a set of guarantees about parallelism that make this simple to
program. Start and stop functions are mutually exclusive and a state is
never used by more than one generate. In other words, a start / generate /
generate / stop sequence works like a&nbsp;thread.</p>
<p><img alt="Sequence" src="Sequence.png" /></p>
<p>(* in fact libvips keeps a cache of calculated pixel buffers and will return
a pointer to a previously-calculated buffer if it&nbsp;can)</p>
<h1 id="operations">Operations<a class="md-anchor" href="#operations" title="Permanent link"></a></h1>
<p>libvips operations read input images and write output images, performing some
transformation on the pixels. When an operation writes to an image the
action it takes depends upon the image type. For example, if the image is a
file on disc then libvips will start a data sink to stream pixels to the file,
or if the image is a partial one then it will just attach start / generate /
stop&nbsp;functions.</p>
<p>Like most threaded image processing systems, all libvips operations have to
be free of side-effects. In other words, operations cannot modify images,
they can only create new images. This could result in a lot of copying if
an operation is only making a small change to a large image so libvips has a
set of mechanisms to copy image areas by just adjusting pointers. Most of
the time no actual copying is necessary and you can perform operations on
large images at low&nbsp;cost.</p>
<h2 id="simd-optimisations">SIMD optimisations<a class="md-anchor" href="#simd-optimisations" title="Permanent link"></a></h2>
<p>libvips uses <a href="https://github.com/google/highway">Highway</a>, a C++ library,
to optimise various operations with <span class="caps">SIMD</span>/vector instructions. These optimised
code paths are flexible and can adapt to different instruction sets, including
those with &#8216;scalable&#8217; vectors (size unknown at compile time). At runtime,
dynamic dispatch selects the best available implementation based on the
processor&#8217;s capabilities, ensuring optimal&nbsp;performance.</p>
<p><span class="caps">SIMD</span> typically speeds operations up by a factor of three or&nbsp;four.</p>
<h2 id="joining-operations-together">Joining operations together<a class="md-anchor" href="#joining-operations-together" title="Permanent link"></a></h2>
<p>The region create / prepare / prepare / free calls you use to get pixels
from an image are an exact parallel to the start / generate / generate /
stop calls that images use to create pixels. In fact, they are the same:
a region on a partial image holds the state created by that image for the
generate function that will fill the region with&nbsp;pixels.</p>
<p><img alt="Combine" src="Combine.png" /></p>
<p>libvips joins image processing operations together by linking the output of one
operation (the start / generate / stop sequence) to the input of the next
(the region it uses to get pixels for processing). This link is a single
function call, and very fast. Additionally, because of the the split between
allocation and processing, once a pipeline of operations has been set up,
libvips is able to run without allocating and freeing&nbsp;memory.</p>
<p>This graph (generated by <code>vipsprofile</code>, the libvips profiler) shows memory use
over time for a libvips pipeline running on a large image. The bottom trace
shows total memory, the upper traces show threads calculating useful results
(green), threads blocked on synchronisation (red) and memory allocations
(white&nbsp;ticks).</p>
<p><img alt="Memtrace" src="Memtrace.png" /></p>
<p>Because the intermediate image is just a small region in memory, a pipeline
of operations running together needs very little <span class="caps">RAM</span>. In fact, intermediates
are small enough that they can fit in L2 cache on most machines, so an
entire pipeline can run without touching main memory. And finally, because
each thread runs a very cheap copy of just the writeable state of the
entire pipeline, threads can run with few locks. libvips needs just four lock
operations per output tile, regardless of the pipeline length or&nbsp;complexity.</p>
<h2 id="data-sources">Data sources<a class="md-anchor" href="#data-sources" title="Permanent link"></a></h2>
<p>libvips has data sources which can supply pixels for processing from a variety
of sources. libvips can stream images from files in libvips native format, from
tiled <span class="caps">TIFF</span> files, from binary <span class="caps">PPM</span>/<span class="caps">PGM</span>/<span class="caps">PBM</span>/<span class="caps">PFM</span>, from Radiance (<span class="caps">HDR</span>) files,
from <span class="caps">FITS</span> images and from tiled OpenEXR images. libvips will automatically
unpack other formats to temporary disc files for you but this can
obviously generate a lot of disc traffic. It also has a special
sequential mode for streaming operations on non-random-access formats. Another
section in these docs explains <a href="how-it-opens-files.html">how libvips opens files</a>. One of the sources uses the <a href="https://imagemagick.org/">ImageMagick</a> (or optionally <a href="http://graphicsmagick.org">GraphicsMagick</a>) library, so libvips can read any image format
that these libraries can&nbsp;read.</p>
<p>libvips images are held on disc as a 64-byte header containing basic image
information like width, height, bands and format, then the image data as
a single large block of pixels, left-to-right and top-to-bottom, then an
<span class="caps">XML</span> extension block holding all the image metadata, such as <span class="caps">ICC</span> profiles
and <span class="caps">EXIF</span>&nbsp;blocks.</p>
<p>When reading from a large libvips image (or any other format with the same
structure on disc, such as binary <span class="caps">PPM</span>), libvips keeps a set of small rolling
windows into the file, some small number of scanlines in size. As pixels
are demanded by different threads libvips will move these windows up and down
the file. As a result, libvips can process images much larger than <span class="caps">RAM</span>, even
on 32-bit&nbsp;machines.</p>
<h2 id="data-sinks">Data sinks<a class="md-anchor" href="#data-sinks" title="Permanent link"></a></h2>
<p>In a demand-driven system, something has to do the demanding. libvips has a
variety of data sinks that you can use to pull image data though a pipeline
in various situations. There are sinks that will build a complete image
in memory, sinks to draw to a display, sinks to loop over an image (useful
for statistical operations, for example) and sinks to stream an image to&nbsp;disc.</p>
<p>The disc sink looks something like&nbsp;this:</p>
<p><img alt="Sink" src="Sink.png" /></p>
<p>The sink keeps two buffers*, each as wide as the image. It starts threads
as rapidly as it can up to the concurrency limit, filling each buffer with
tiles** of calculated pixels, each thread calculating one tile at once. A
separate background thread watches each buffer and, as soon as the last tile
in a buffer finishes, writes that complete set of scanlines to disc using
whatever image write library is appropriate. libvips can write with libjpeg,
libtiff, libpng and others. It then wipes the buffer and repositions it
further down the image, ready for the next set of tiles to stream&nbsp;in.</p>
<p>These features in combination mean that, once a pipeline of image processing
operations has been built, libvips can run almost lock-free. This is very
important for <span class="caps">SMP</span> scaling: you don&#8217;t want the synchronization overhead to
scale with either the number of threads or the complexity of the pipeline
of operations being performed. As a result, libvips scales almost linearly
with increasing numbers of&nbsp;threads:</p>
<p><img alt="SMP scaling" src="Vips-smp.png" /></p>
<p>Number of CPUs is on the horizontal axis, speedup is on the vertical
axis. Taken from the [[Benchmarks]]&nbsp;page.</p>
<p>(* there can actually be more than one, it allocate enough buffers to
ensure that there are at least two tiles for every&nbsp;thread)</p>
<p>(** tiles can be any shape and size, libvips has a tile hint system that
operations use to tell sinks what tile geometry they&nbsp;prefer)</p>
<h2 id="operation-cache">Operation cache<a class="md-anchor" href="#operation-cache" title="Permanent link"></a></h2>
<p>Because libvips operations are free of side-effects*, you can cache them. Every
time you call an operation, libvips searches the cache for a previous call to
the same operation with the same arguments. If it finds a match, you get
the previous result again. This can give a huge&nbsp;speedup.</p>
<p>By default, libvips caches the last 100 operation calls. You can also control
the cache size by memory use or by files&nbsp;opened.</p>
<p>(* Some libvips operations <span class="caps">DO</span> have side effects, for example,
<a href="method.Image.draw_circle.html"><code>vips_draw_circle()</code></a> will draw a circle on an image. These operations emit an
&#8220;invalidate&#8221; signal on the image they are called on and this signal makes
all downstream operations and caches drop their&nbsp;contents.)</p>
<h2 id="operation-database-and-apis">Operation database and APIs<a class="md-anchor" href="#operation-database-and-apis" title="Permanent link"></a></h2>
<p>libvips has around 300 image processing operations written in this style. Each
operation is a GObject class. You can use the standard GObject calls to walk
the class hierarchy and discover operations, and libvips adds a small amount
of extra introspection metadata to handle things like optional&nbsp;arguments.</p>
<p>The <a href="using-from-c.md">C <span class="caps">API</span></a> is a set of simple wrappers
which create class instances for you. The <a href="using-from-cplusplus.md">C++ <span class="caps">API</span></a>
is a little fancier and adds things like automatic object lifetime
management. The <a href="using-the-cli.md">command-line interface</a>
uses introspection to run any libvips operation in the class&nbsp;hierarchy.</p>
<p>There are bindings for <a href="https://www.libvips.org/">many other languages</a> on
many platforms. Most of these bindings use the introspection system to
generate the binding at&nbsp;run-time.</p>
<h2 id="snip">Snip<a class="md-anchor" href="#snip" title="Permanent link"></a></h2>
<p>The libvips <span class="caps">GUI</span>, nip2, has its own scripting language called Snip. Snip is a
lazy, higher-order, purely functional, object oriented language. Almost all
of nip2&#8217;s menus are implemented in it, and nip2 workspaces are Snip&nbsp;programs.</p>
<p>libvips operations listed in the operation database appear as Snip functions. For
example, <code>abs</code> can be used from Snip&nbsp;as:</p>
<div class="codehilite"><pre><span></span><code>// absolute value of image b
a = vips_call &quot;abs&quot; [b] [];
</code></pre></div>

<p>However, <code>abs</code> won&#8217;t work on anything except the primitive <code>.v</code> image type.
It can&#8217;t be used on any class, or list or number. Definitions in <code>_stdenv.dev</code>
wrap each libvips operation as a higher level Snip operation. For&nbsp;example:</p>
<div class="codehilite"><pre><span></span><code>abs x
    = oo_unary_function abs_op x, is_class x
    = vips_call &quot;abs&quot; [x] [], is_image x
    = abs_cmplx x, is_complex x
    = abs_num x, is_real x
    = abs_list x, is_real_list x
    = abs_list (map abs_list x), is_matrix x
    = error (_ &quot;bad arguments to &quot; ++ &quot;abs&quot;)
{
    abs_op = Operator &quot;abs&quot; abs Operator_type.COMPOUND false;

    abs_list l = (sum (map square l)) ** 0.5;

    abs_num n
        = n, n &gt;= 0
        = -n;

    abs_cmplx c = ((re c)**2 + (im c)**2) ** 0.5;
}
</code></pre></div>

<p>This defines the behaviour of <code>abs</code> for the base Snip types (number, list,
matrix, image and so on), then classes will use that to define operator
behaviour on higher-level&nbsp;objects.</p>
<p>Now you can&nbsp;use:</p>
<div class="codehilite"><pre><span></span><code>// absolute value of anything
a = abs b;
</code></pre></div>

<p>and you ought to get sane behaviour for any object, including things like
the <code>Matrix</code> class.</p>
<p>You can write Snip classes which present functions to the user as menu
items. For example, <code>Math.def</code> has&nbsp;this:</p>
<div class="codehilite"><pre><span></span><code>Math_arithmetic_item = class
    Menupullright &quot;_Arithmetic&quot; &quot;basic arithmetic for objects&quot; {

    Absolute_value_item = class
        Menuaction &quot;A_bsolute Value&quot; &quot;absolute value of x&quot; {
        action x = map_unary abs x;
    }
}
</code></pre></div>

<p>Now the user can select an object and click <code>Math / Abs</code> to find the absolute
value of that&nbsp;object.</p>
    </div>
  </section>
</section>


    
<div id="toc" class="toc">
  <nav aria-labelledby="toc-title">
    <p id="toc-title">Content</p>
    <ul class="toc-list">
      
        
        <li class="toc-list-item"><a href="#images"><span class="link-text">Images</span></a></li>
          
        
        <li class="toc-list-item"><a href="#regions"><span class="link-text">Regions</span></a></li>
          
        
        <li class="toc-list-item"><a href="#partial-images"><span class="link-text">Partial images</span></a></li>
          
        
        <li class="toc-list-item"><a href="#operations"><span class="link-text">Operations</span></a></li>
          
          <ul class="toc-list">
          
            <li class="toc-list-item"><a href="#simd-optimisations"><span class="link-text">SIMD optimisations</span></a></li>
          
            <li class="toc-list-item"><a href="#joining-operations-together"><span class="link-text">Joining operations together</span></a></li>
          
            <li class="toc-list-item"><a href="#data-sources"><span class="link-text">Data sources</span></a></li>
          
            <li class="toc-list-item"><a href="#data-sinks"><span class="link-text">Data sinks</span></a></li>
          
            <li class="toc-list-item"><a href="#operation-cache"><span class="link-text">Operation cache</span></a></li>
          
            <li class="toc-list-item"><a href="#operation-database-and-apis"><span class="link-text">Operation database and APIs</span></a></li>
          
            <li class="toc-list-item"><a href="#snip"><span class="link-text">Snip</span></a></li>
          
          </ul>
          
        
      
    </ul>
  </nav>
</div>


    <section id="search" class="content hidden"></section>

    <footer>
    
    </footer>
  </div>
</body>
</html>