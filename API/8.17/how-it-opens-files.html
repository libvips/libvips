<!--
SPDX-FileCopyrightText: libvips team and contributors

SPDX-License-Identifier: LGPL-2.1-or-later
-->

<!DOCTYPE html>
<html lang="en">
<head>
  <title>Vips &ndash; 8.0: Technical background &gt; Opening files</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta charset="utf-8" />

  
  <meta property="og:type" content="website"/>

  

  
  <meta property="og:title" content="Vips: Technical background &gt; Opening files"/>
  <meta property="og:description" content="Reference for Vips-8.0: Technical background &gt; Opening files"/>
  <meta name="twitter:title" content="Vips: Technical background &gt; Opening files"/>
  <meta name="twitter:description" content="Reference for Vips-8.0: Technical background &gt; Opening files"/>


  
  <meta name="twitter:card" content="summary"/>

  
  
  
  <link rel="search" type="application/opensearchdescription+xml" title="Vips" href="opensearch.xml">
  
  

  <link rel="stylesheet" href="style.css" type="text/css" />

  

  
  <script src="urlmap.js"></script>
  
  
  <script src="fzy.js"></script>
  <script src="search.js"></script>
  
  <script src="main.js"></script>

  
</head>

<body>
  <div id="body-wrapper" tabindex="-1">

    <nav class="sidebar devhelp-hidden">
      
      
      <div class="search section">
        <form id="search-form" autocomplete="off">
          <input id="search-input" type="text" name="do-not-autocomplete" placeholder="Click, or press 's' to search" autocomplete="off"/>
        </form>
      </div>
      
      <div class="section namespace">
        <h3><a href="index.html">Vips</a></h3>
        <p>API Version: 8.0</p>
        
        <p>Library Version: 8.17</p>
        
      </div>
      
      
      <div class="section generator">
        <p>Generated by <a href="https://gitlab.gnome.org/GNOME/gi-docgen">gi-docgen</a> 2025.3</p>
      </div>
    </nav>

    <button id="btn-to-top" class="hidden"><span class="up-arrow"></span></button>

    
<section id="main" class="content">
  
  <h4 id="title" style="display:flex;">
    Technical background &gt; Opening files
    <a href="#title" class="anchor"></a>
    
    <a class="srclink" title="go to source location" href="https://github.com/libvips/libvips/blob/master/doc/how-it-opens-files.md">[src]</a>
    
  </h4>
  
  <section>
    <div class="docblock">
    <p>libvips has at least four different ways of opening image files, each
best for different file types, file sizes and image use cases. libvips tries
hard to pick the best strategy in each case and mostly you don&#8217;t need to
know what it is doing behind the scenes, except unfortunately when you&nbsp;do.</p>
<p>This page tries to explain what the different strategies are and when each is
used. If you are running into unexpected memory, disc or <span class="caps">CPU</span> use, this might
be helpful. <a href="ctor.Image.new_from_file.html"><code>vips_image_new_from_file()</code></a> has the official&nbsp;documentation.</p>
<h2 id="caching">Caching<a class="md-anchor" href="#caching" title="Permanent link"></a></h2>
<p>libvips caches recent operations. This means that if a file changes between
one load and the next, the second load will return the old image, even though
the file has been&nbsp;replaced.</p>
<p>You can force libvips to load a file and ignore any cached value by
setting the <code>revalidate</code> flag, see <a href="class.ForeignLoad.html"><code>VipsForeignLoad</code></a>.</p>
<h2 id="direct-access">Direct access<a class="md-anchor" href="#direct-access" title="Permanent link"></a></h2>
<p>This is the fastest and simplest one. The file is mapped directly into the
process&#8217;s address space and can be read with ordinary pointer access. Small
files are completely mapped; large files are mapped in a series of small
windows that are shared and which scroll about as pixels are read. Files
which are accessed like this can be read by many threads at once, making
them especially quick. They also interact well with the computer&#8217;s operating
system: your <span class="caps">OS</span> will use spare memory to cache recently used chunks of the&nbsp;file.</p>
<p>For this to be possible, the file format needs to be a simple dump of a memory
array. libvips supports direct access for <code>.v</code>, 8-bit binary ppm/pbm/pnm,
analyse and&nbsp;raw.</p>
<p>libvips has a special direct write mode where pixels can be written directly
to the file image. This is used for the <a href="libvips-draw.html">draw operations</a>.</p>
<h2 id="random-access-via-load-library">Random access via load library<a class="md-anchor" href="#random-access-via-load-library" title="Permanent link"></a></h2>
<p>Some image file formats have libraries which allow true random access to
image pixels. For example, libtiff lets you read any tile out of a tiled
tiff image very quickly. Because the libraries allow true random access,
libvips can simply hook the image load library up to the input of the
operation&nbsp;pipeline.</p>
<p>These libraries are generally single-threaded, so only one thread may
read at once, making them slower than simple direct access.
Additionally, tiles are often compressed, meaning that each time a tile
is fetched it must be decompressed. libvips keeps a cache of
recently-decompressed tiles to try to avoid repeatedly decompressing the
same&nbsp;tile.</p>
<p>libvips can load tiled tiff, tiled OpenEXR, <span class="caps">FITS</span> and OpenSlide images in
this&nbsp;manner.</p>
<h2 id="full-decompression">Full decompression<a class="md-anchor" href="#full-decompression" title="Permanent link"></a></h2>
<p>Many image load libraries do not support random access. In order to use
images of this type as inputs to pipelines, libvips has to convert them
to a random access format&nbsp;first.</p>
<p>For small images (less than 100mb when decompressed), libvips allocates
a large area of memory and decompresses the entire image to that. It
then uses that memory buffer of decompressed pixels to feed the
pipeline. For large images, libvips decompresses to a temporary file on
disc, then loads that temporary file in direct access mode (see above).
Note that on open libvips just reads the image header and is quick: the
image decompress happens on the first pixel&nbsp;access.</p>
<p>You can control this process with environment variables, command-line
flags and <span class="caps">API</span> calls as you choose, see <a href="ctor.Image.new_from_file.html"><code>vips_image_new_from_file()</code></a>.
They let you set the threshold at which libvips switches between memory
and disc and where on disc the temporary files are&nbsp;held.</p>
<p>This is the slowest and most memory-hungry way to read files, but it&#8217;s
unavoidable for many file formats. Unless you can use the next&nbsp;one!</p>
<h2 id="sequential-access">Sequential access<a class="md-anchor" href="#sequential-access" title="Permanent link"></a></h2>
<p>This a fairly recent addition to libvips and is a hybrid of the previous&nbsp;two.</p>
<p>Imagine how this command might be&nbsp;executed:</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span>vips<span class="w"> </span>flip<span class="w"> </span>fred.jpg<span class="w"> </span>jim.jpg<span class="w"> </span>vertical
</code></pre></div>

<p>meaning, read <code>fred.jpg</code>, flip it up-down, and write as <code>jim.jpg</code>.</p>
<p>In order to write <code>jim.jpg</code> top-to-bottom, it&#8217;ll have to read <code>fred.jpg</code>
bottom-to-top. Unfortunately libjpeg only supports top-to-bottom reading
and writing, so libvips must convert <code>fred.jpg</code> to a random access format
before it can run the flip&nbsp;operation.</p>
<p>However many useful operations do not require true random access. For&nbsp;example:</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span>vips<span class="w"> </span>shrink<span class="w"> </span>fred.png<span class="w"> </span>jim.png<span class="w"> </span><span class="m">10</span><span class="w"> </span><span class="m">10</span>
</code></pre></div>

<p>meaning shrink <code>fred.png</code> by a factor of 10 in both axes and write as
<code>jim.png</code>.</p>
<p>You can imagine this operation running without needing <code>fred.png</code> to be
completely decompressed first. You just read 10 lines from <code>fred.png</code> for
every one line you write to <code>jim.png</code>.</p>
<p>To help in this case, libvips has a hint you can give to loaders to say
&#8220;I will only need pixels from this image in top-to-bottom order&#8221;. With
this hint set, libvips will hook up the pipeline of operations directly
to the read-a-line interface provided by the image library, and add a
small cache of the most recent 100 or so&nbsp;lines.</p>
<p>This is done automatically in command-line operation. In programs, you need to
set <code>access</code> to #VIPS_ACCESS_SEQUENTIAL in calls to functions like
<a href="ctor.Image.new_from_file.html"><code>vips_image_new_from_file()</code></a>.</p>
    </div>
  </section>
</section>


    
<div id="toc" class="toc">
  <nav aria-labelledby="toc-title">
    <p id="toc-title">Content</p>
    <ul class="toc-list">
      
        
        <li class="toc-list-item"><a href="#caching"><span class="link-text">Caching</span></a></li>
          
        
        <li class="toc-list-item"><a href="#direct-access"><span class="link-text">Direct access</span></a></li>
          
        
        <li class="toc-list-item"><a href="#random-access-via-load-library"><span class="link-text">Random access via load library</span></a></li>
          
        
        <li class="toc-list-item"><a href="#full-decompression"><span class="link-text">Full decompression</span></a></li>
          
        
        <li class="toc-list-item"><a href="#sequential-access"><span class="link-text">Sequential access</span></a></li>
          
        
      
    </ul>
  </nav>
</div>


    <section id="search" class="content hidden"></section>

    <footer>
    
    </footer>
  </div>
</body>
</html>