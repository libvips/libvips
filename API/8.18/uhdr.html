<!--
SPDX-FileCopyrightText: libvips team and contributors

SPDX-License-Identifier: LGPL-2.1-or-later
-->

<!DOCTYPE html>
<html lang="en">
<head>
  <title>Vips &ndash; 8.0: Using &gt; Processing UltraHDR images</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta charset="utf-8" />

  
  <meta property="og:type" content="website"/>

  

  
  <meta property="og:title" content="Vips: Using &gt; Processing UltraHDR images"/>
  <meta property="og:description" content="Reference for Vips-8.0: Using &gt; Processing UltraHDR images"/>
  <meta name="twitter:title" content="Vips: Using &gt; Processing UltraHDR images"/>
  <meta name="twitter:description" content="Reference for Vips-8.0: Using &gt; Processing UltraHDR images"/>


  
  <meta name="twitter:card" content="summary"/>

  
  
  
  <link rel="search" type="application/opensearchdescription+xml" title="Vips" href="opensearch.xml">
  
  

  <link rel="stylesheet" href="style.css" type="text/css" />

  

  
  <script src="urlmap.js"></script>
  
  
  <script src="fzy.js"></script>
  <script src="search.js"></script>
  
  <script src="main.js"></script>

  
</head>

<body>
  <div id="body-wrapper" tabindex="-1">

    <nav class="sidebar devhelp-hidden">
      
      
      <div class="search section">
        <form id="search-form" autocomplete="off">
          <input id="search-input" type="text" name="do-not-autocomplete" placeholder="Click, or press 's' to search" autocomplete="off"/>
        </form>
      </div>
      
      <div class="section namespace">
        <h3><a href="index.html">Vips</a></h3>
        <p>API Version: 8.0</p>
        
        <p>Library Version: 8.18</p>
        
      </div>
      
      
      <div class="section generator">
        <p>Generated by <a href="https://gitlab.gnome.org/GNOME/gi-docgen">gi-docgen</a> 2025.3</p>
      </div>
    </nav>

    <button id="btn-to-top" class="hidden"><span class="up-arrow"></span></button>

    
<section id="main" class="content">
  
  <h4 id="title" style="display:flex;">
    Using &gt; Processing UltraHDR images
    <a href="#title" class="anchor"></a>
    
    <a class="srclink" title="go to source location" href="https://github.com/libvips/libvips/blob/master/doc/uhdr.md">[src]</a>
    
  </h4>
  
  <section>
    <div class="docblock">
    <p>libvips can process <span class="caps">HDR</span> images encoded with
<a href="https://en.wikipedia.org/wiki/Ultra_HDR">UltraHDR</a>. These are ordinary
<span class="caps">SDR</span> images, but with a gainmap embedded within them &#8212; <span class="caps">SDR</span> displays will
just show the regular <span class="caps">SDR</span> image, but for an <span class="caps">HDR</span> display, the extra gainmap
can be used as an exponent to recover the full <span class="caps">HDR</span> range. This ability to show
the same file in good quality on both <span class="caps">SDR</span> and <span class="caps">HDR</span> displays makes the format
very&nbsp;useful.</p>
<p>libvips uses Google&#8217;s <a href="https://github.com/google/libultrahdr">libultrahdr</a>
for UltraHDR load and save. The current version of this library only
supports UltraHDR <span class="caps">JPEG</span> images; the next version is expected to add support
for a wider range of image&nbsp;formats.</p>
<p>There are two main paths for UltraHDR images in libvips: as an <span class="caps">SDR</span> image with a
separate gainmap, and as a full <span class="caps">HDR</span> image. The separate gainmap path is
relatively fast but you will sometimes need to update the gainmap during
processing. The full <span class="caps">HDR</span> path does not require gainmap updates, but can be
slower, and will usually lose the original image&#8217;s tone&nbsp;mapping.</p>
<h2 id="ultrahdr-as-sdr-with-a-separate-gainmap">UltraHDR as SDR with a separate gainmap<a class="md-anchor" href="#ultrahdr-as-sdr-with-a-separate-gainmap" title="Permanent link"></a></h2>
<p>libvips will detect <span class="caps">JPEG</span> images with an embedded gainmap and automatically
invoke the <a href="ctor.Image.uhdrload.html"><code>vips_uhdrload()</code></a> operation to load them. This operation
attaches the gainmap (a small <span class="caps">JPEG</span>-compressed image) as the <code>"gainmap-data"</code>
metadata item, plus some other gainmap&nbsp;tags.</p>
<h3 id="load-and-save">Load and save<a class="md-anchor" href="#load-and-save" title="Permanent link"></a></h3>
<p>For&nbsp;example:</p>
<div class="codehilite"><pre><span></span><code>$ vipsheader -a ultra-hdr.jpg
ultra-hdr.jpg: 3840x2160 uchar, 3 bands, srgb, uhdrload
width: 3840
height: 2160
bands: 3
format: uchar
coding: none
interpretation: srgb
xoffset: 0
yoffset: 0
xres: 1
yres: 1
filename: ultra-hdr.jpg
vips-loader: uhdrload
icc-profile-data: 588 bytes of binary data
gainmap-data: 31738 bytes of binary data
gainmap-max-content-boost: 100 100 100
gainmap-min-content-boost: 1 1 1
gainmap-gamma: 1 1 1
gainmap-offset-sdr: 0 0 0
gainmap-offset-hdr: 0 0 0
gainmap-hdr-capacity-min: 1
gainmap-hdr-capacity-max: 100
gainmap-use-base-cg: 1
</code></pre></div>

<p>This gainmap metadata is copied unmodified through any processing operations.
If you save an image with gainmap metadata to a <span class="caps">JPEG</span> file, libvips will do the
write with the <a href="method.Image.uhdrsave.html"><code>vips_uhdrsave()</code></a> operation, embedding the gainmap and the
associated metadata in the output&nbsp;image.</p>
<p>Intermediate operations which change the image geometry will also need to
update the <code>"gainmap-data"</code> metadata item, the mechanisms for doing this are
described below. The other gainmap fields should probably not be changed
unless the intention is to alter the image&nbsp;appearance.</p>
<h3 id="high-level-libvips-operations">High-level libvips operations<a class="md-anchor" href="#high-level-libvips-operations" title="Permanent link"></a></h3>
<p>Two high-level libvips operations will automatically update the gainmap for
you during processing: <a href="method.Image.dzsave.html"><code>vips_dzsave()</code></a> and <a href="ctor.Image.thumbnail.html"><code>vips_thumbnail()</code></a>.</p>
<p><a href="method.Image.dzsave.html"><code>vips_dzsave()</code></a> always strips all metadata by default, so you&#8217;ll need to
set <code>keep="gainmap"</code> to write the gainmap to the tiles. For&nbsp;example:</p>
<div class="codehilite"><pre><span></span><code>$ vips dzsave ultra-hdr.jpg x --keep gainmap
</code></pre></div>

<h3 id="a-la-carte-processing">À la carte processing<a class="md-anchor" href="#a-la-carte-processing" title="Permanent link"></a></h3>
<p>Other operations will <span class="caps">NOT</span> automatically update the gainmap for you. If you
call something like <a href="method.Image.crop.html"><code>vips_crop()</code></a>, an operation which changes the
image geometry, the gainmap and the image will no longer match. When
you save the cropped image, the gainmap is likely to be&nbsp;incorrect.</p>
<p>A helper function, <a href="method.Image.get_gainmap.html"><code>vips_image_get_gainmap()</code></a>, makes updating the gainmap
relatively easy: it returns a <a href="class.Image.html"><code>VipsImage</code></a> for the gainmap, and attaches
the image pointer as the metadata item <code>"gainmap"</code>. Once you have updated
the gainmap, you can overwrite this&nbsp;value.</p>
<p>For example, in C you could&nbsp;write</p>
<div class="codehilite"><pre><span></span><code><span class="n">VipsImage</span><span class="w"> </span><span class="o">*</span><span class="n">image</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="n">VipsImage</span><span class="w"> </span><span class="o">*</span><span class="n">out</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">top</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">;</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">vips_crop</span><span class="p">(</span><span class="n">image</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">top</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">))</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>

<span class="c1">// also crop the gainmap, if there is one</span>
<span class="n">VipsImage</span><span class="w"> </span><span class="o">*</span><span class="n">gainmap</span><span class="p">;</span>
<span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">gainmap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vips_image_get_gainmap</span><span class="p">(</span><span class="n">out</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// the gainmap can be smaller than the image, we must scale the</span>
<span class="w">    </span><span class="c1">// crop area</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">hscale</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="n">gainmap</span><span class="o">-&gt;</span><span class="n">Xsize</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">image</span><span class="o">-&gt;</span><span class="n">Xsize</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">vscale</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="n">gainmap</span><span class="o">-&gt;</span><span class="n">Ysize</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">image</span><span class="o">-&gt;</span><span class="n">Ysize</span><span class="p">;</span>

<span class="w">    </span><span class="n">VipsImage</span><span class="w"> </span><span class="o">*</span><span class="n">new_gainmap</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">vips_crop</span><span class="p">(</span><span class="n">gainmap</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">new_gainmap</span><span class="p">,</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">hscale</span><span class="p">,</span><span class="w"> </span><span class="n">top</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">vscale</span><span class="p">,</span>
<span class="w">        </span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">hscale</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">vscale</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">))</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="n">g_object_unref</span><span class="p">(</span><span class="n">gainmap</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// vips_image_set_image() modifies the image, so we need to make a</span>
<span class="w">    </span><span class="c1">// unique copy ... you can skip this step if you know your image is</span>
<span class="w">    </span><span class="c1">// already unique</span>
<span class="w">    </span><span class="n">VipsImage</span><span class="w"> </span><span class="o">*</span><span class="n">new_out</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">vips_copy</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">new_out</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">g_object_unref</span><span class="p">(</span><span class="n">new_gainmap</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">g_object_unref</span><span class="p">(</span><span class="n">out</span><span class="p">);</span>
<span class="w">    </span><span class="n">out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_out</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// update the gainmap</span>
<span class="w">    </span><span class="n">vips_image_set_image</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;gainmap&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">new_gainmap</span><span class="p">);</span>

<span class="w">    </span><span class="n">g_object_unref</span><span class="p">(</span><span class="n">new_gainmap</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>Or with&nbsp;ruby-vips:</p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">crop_image_and_gainmap</span><span class="p">(</span><span class="n">image</span><span class="p">,</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">top</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">)</span>
<span class="w">  </span><span class="n">image</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">image</span><span class="o">.</span><span class="n">crop</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">top</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span>
<span class="w">  </span><span class="n">gainmap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">image</span><span class="o">.</span><span class="n">get_gainmap</span>
<span class="w">  </span><span class="k">unless</span><span class="w"> </span><span class="n">gainmap</span><span class="o">.</span><span class="n">nil?</span>
<span class="w">    </span><span class="n">hscale</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gainmap</span><span class="o">.</span><span class="n">width</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">image</span><span class="o">.</span><span class="n">width</span>
<span class="w">    </span><span class="n">vscale</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gainmap</span><span class="o">.</span><span class="n">height</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">image</span><span class="o">.</span><span class="n">height</span>
<span class="w">    </span><span class="n">new_gainmap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gainmap</span><span class="o">.</span><span class="n">crop</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">hscale</span><span class="p">,</span><span class="w"> </span><span class="n">top</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">vscale</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">hscale</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">vscale</span>
<span class="w">    </span><span class="n">image</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">image</span><span class="o">.</span><span class="n">mutate</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="o">|</span><span class="n">mutable</span><span class="o">|</span>
<span class="w">      </span><span class="n">mutable</span><span class="o">.</span><span class="n">set_type!</span><span class="w"> </span><span class="no">Vips</span><span class="o">::</span><span class="no">IMAGE_TYPE</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;gainmap&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">new_gainmap</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="n">image</span>
<span class="k">end</span>
</code></pre></div>

<h3 id="performance-and-quality-considerations">Performance and quality considerations<a class="md-anchor" href="#performance-and-quality-considerations" title="Permanent link"></a></h3>
<p>Doing gainmap processing explicitly like this has two big advantages:
first, you have exact control over this processing, so you can make sure
only the gainmap transformations that are strictly necessary take place.
Secondly, since you supply the gainmap to the UltraHDR save, you can also
be certain any user tone mapping is&nbsp;preserved.</p>
<p>The disadvantage is the extra development work necessary. The second UltraHDR
path in libvips avoids this&nbsp;problem.</p>
<h2 id="full-hdr-processing">Full HDR processing<a class="md-anchor" href="#full-hdr-processing" title="Permanent link"></a></h2>
<p>You can transform an UltraHDR <span class="caps">SDR</span> plus gainmap image to full <span class="caps">HDR</span> with
<a href="method.Image.uhdr2scRGB.html"><code>vips_uhdr2scRGB()</code></a>. This will compute an scRGB image: a three-band
float with sRGB primaries, black to white as linear 0-1, and out of range
values used to represent <span class="caps">HDR</span>.</p>
<p>For&nbsp;example:</p>
<div class="codehilite"><pre><span></span><code>$ vips uhdr2scRGB ultra-hdr.jpg x.v
$ vipsheader x.v
x.v: 3840x2160 float, 3 bands, scrgb, uhdrload
$ vips max x.v
15.210938
</code></pre></div>

<p>If you save an scRGB image as <span class="caps">JPEG</span>, it will be automatically written as
UltraJPEG. Any associated gainmap is thrown away and basic tonemapping
performed to make a new gainmap for <span class="caps">SDR</span>&nbsp;display.</p>
<p>Full <span class="caps">HDR</span> processing with scRGB is simple, but potentially slower than the
separate gainmap path, and will not preserve any user tone&nbsp;map.</p>
    </div>
  </section>
</section>


    
<div id="toc" class="toc">
  <nav aria-labelledby="toc-title">
    <p id="toc-title">Content</p>
    <ul class="toc-list">
      
        
        <li class="toc-list-item"><a href="#ultrahdr-as-sdr-with-a-separate-gainmap"><span class="link-text">UltraHDR as SDR with a separate gainmap</span></a></li>
          
          <ul class="toc-list">
          
            <li class="toc-list-item"><a href="#load-and-save"><span class="link-text">Load and save</span></a></li>
          
            <li class="toc-list-item"><a href="#high-level-libvips-operations"><span class="link-text">High-level libvips operations</span></a></li>
          
            <li class="toc-list-item"><a href="#a-la-carte-processing"><span class="link-text">À la carte processing</span></a></li>
          
            <li class="toc-list-item"><a href="#performance-and-quality-considerations"><span class="link-text">Performance and quality considerations</span></a></li>
          
          </ul>
          
        
        <li class="toc-list-item"><a href="#full-hdr-processing"><span class="link-text">Full HDR processing</span></a></li>
          
        
      
    </ul>
  </nav>
</div>


    <section id="search" class="content hidden"></section>

    <footer>
    
    </footer>
  </div>
</body>
</html>